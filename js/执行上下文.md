# 执行上下文
有全局上下文,函数上下文

在代码执行时,会将新创建的上下文压入上下文栈中,先进后出

> 执行上下文创建步骤
>> 1. 在函数执行之后,会创建一个执行上下文<br/>
>> 2. 将函数创建之前存储的作用域写入<br/>
>> 3. 创建arguments对象<br/>
>> 4. 创建活动对象,给变量对象添加形参、函数声明、变量声明等初始的属性值
>> 5. 将当前的函数所作用域压入作用域栈中 (注意:当前的函数作用域也都一样存储了变量)<br/>
>> 6. 准备阶段完毕,根据代码的执行,赋值对应的变量参数

## 题目
```js
function foo() {
    console.log(a);
    a = 1;
}

foo(); // ???

function bar() {
    a = 1;
    console.log(a);
}
bar(); // ???

// 第一段会报错：Uncaught ReferenceError: a is not defined。
// 第二段会打印：1。
// 这是因为函数中的 "a" 并没有通过 var 关键字声明，所有不会被存放在 AO 中
// 第一段执行 console 的时候， AO 的值是：
AO = {
    arguments: {
        length: 0
    }
}

// 没有 a 的值，然后就会到全局去找，全局也没有，所以会报错。
// 当第二段执行 console 的时候，全局对象已经被赋予了 a 属性，这时候就可以从全局找到 a 的值，所以会打印 1。
// 
```


## 总结
1. 全局执行上下文由浏览器创建 , 代码执行时就会创建; 函数执行上下文只有在函数执行时会创建,调用多少次,执行多少次
2. 调用栈用于存放所有执行上下文,先进后出
3. 执行上下文创建阶段会绑定this , 创建词法环境, 和变量环境三个步骤 ; 
   两者的区别在于,创建词法环境时,只绑定let 和const , 变量环境只保存var申明的变量,且var默认是undefined , 而let 和const则是uninitialized(未初始化) , 这就是为什么有函数变量提升,和let,const没有暂时性死域
